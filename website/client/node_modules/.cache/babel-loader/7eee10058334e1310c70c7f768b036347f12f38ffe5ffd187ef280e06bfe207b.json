{"ast":null,"code":"var _jsxFileName = \"/Users/jp/Downloads/2024Fall/CIS 5500/CIS-550/website/client/src/components/LazyTable.js\",\n  _s = $RefreshSig$();\nimport { useEffect, useState } from 'react';\nimport { Table, TableBody, TableCell, TableContainer, TableHead, TablePagination, TableRow } from '@mui/material';\n\n// This component provides a paginated MUI table that fetches data only from the specified page.\n// This optimization is known as lazy loading. It is unnecessary for you to utilize this optimization\n// in your final project, but is a good example of many React features and presented as an exercise.\n\n// Take a look at the definition of the LazyTable component. The parameters represent the properties (props)\n// passed into the component. Some of these props are optional (defaultPageSize, rowsPerPageOptions) while\n// others are required (routes, columns). Though not indicated by code, whether the props are optional or\n// required will affect how you handle them in the code.\nexport default function LazyTable(_ref) {\n  _s();\n  let {\n    route,\n    columns,\n    defaultPageSize,\n    rowsPerPageOptions\n  } = _ref;\n  const [data, setData] = useState([]);\n  const [page, setPage] = useState(1); // 1 indexed\n  const [pageSize, setPageSize] = useState(defaultPageSize !== null && defaultPageSize !== void 0 ? defaultPageSize : 10);\n\n  // Now notice the dependency array contains route, page, pageSize, since we\n  // need to re-fetch the data if any of these values change\n  useEffect(() => {\n    fetch(`${route}?page=${page}&page_size=${pageSize}`).then(res => res.json()).then(resJson => setData(resJson));\n  }, [route, page, pageSize]);\n  const handleChangePage = (e, newPage) => {\n    // Can always go to previous page (TablePagination prevents negative pages)\n    // but only fetch next page if we haven't reached the end (currently have full page of data)\n    if (newPage < page || data.length === pageSize) {\n      // Note that we set newPage + 1 since we store as 1 indexed but the default pagination gives newPage as 0 indexed\n      setPage(newPage + 1);\n    }\n  };\n  const handleChangePageSize = e => {\n    // when handling events such as changing a selection box or typing into a text box,\n    // the handler is called with parameter e (the event) and the value is e.target.value\n    const newPageSize = e.target.value;\n    // task 18\n    setPageSize(newPageSize);\n    setPage(1);\n  };\n  const defaultRenderCell = (col, row) => {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 45,\n        columnNumber: 12\n      }\n    }, row[col.field]);\n  };\n  return /*#__PURE__*/React.createElement(TableContainer, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 49,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(Table, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 50,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(TableHead, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 51,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(TableRow, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 52,\n      columnNumber: 11\n    }\n  }, columns.map(col => /*#__PURE__*/React.createElement(TableCell, {\n    key: col.headerName,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 53,\n      columnNumber: 33\n    }\n  }, col.headerName)))), /*#__PURE__*/React.createElement(TableBody, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 56,\n      columnNumber: 9\n    }\n  }, data.map((row, idx) => /*#__PURE__*/React.createElement(TableRow, {\n    key: idx,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 58,\n      columnNumber: 13\n    }\n  }, columns.map(col =>\n  /*#__PURE__*/\n  // TODO (TASK 19): the next 3 lines of code render only the first column. Wrap this with another map statement to render all columns.\n  // Hint: look at how we structured the map statement to render all the table headings within the <TableHead> element\n  React.createElement(TableCell, {\n    key: col.headerName,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 62,\n      columnNumber: 17\n    }\n  }, col.renderCell ? col.renderCell(row) : defaultRenderCell(col, row)))))), /*#__PURE__*/React.createElement(TablePagination, {\n    rowsPerPageOptions: rowsPerPageOptions !== null && rowsPerPageOptions !== void 0 ? rowsPerPageOptions : [5, 10, 25],\n    count: -1,\n    rowsPerPage: pageSize,\n    page: page - 1,\n    onPageChange: handleChangePage,\n    onRowsPerPageChange: handleChangePageSize,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 70,\n      columnNumber: 9\n    }\n  })));\n}\n_s(LazyTable, \"SiuI96L5yLvVz1XQQkRTX51vRSg=\");\n_c = LazyTable;\nvar _c;\n$RefreshReg$(_c, \"LazyTable\");","map":{"version":3,"names":["useEffect","useState","Table","TableBody","TableCell","TableContainer","TableHead","TablePagination","TableRow","LazyTable","route","columns","defaultPageSize","rowsPerPageOptions","data","setData","page","setPage","pageSize","setPageSize","fetch","then","res","json","resJson","handleChangePage","e","newPage","length","handleChangePageSize","newPageSize","target","value","defaultRenderCell","col","row","field","map","headerName","idx","renderCell"],"sources":["/Users/jp/Downloads/2024Fall/CIS 5500/CIS-550/website/client/src/components/LazyTable.js"],"sourcesContent":["import { useEffect, useState } from 'react';\nimport { Table, TableBody, TableCell, TableContainer, TableHead, TablePagination, TableRow } from '@mui/material';\n\n// This component provides a paginated MUI table that fetches data only from the specified page.\n// This optimization is known as lazy loading. It is unnecessary for you to utilize this optimization\n// in your final project, but is a good example of many React features and presented as an exercise.\n\n// Take a look at the definition of the LazyTable component. The parameters represent the properties (props)\n// passed into the component. Some of these props are optional (defaultPageSize, rowsPerPageOptions) while\n// others are required (routes, columns). Though not indicated by code, whether the props are optional or\n// required will affect how you handle them in the code.\nexport default function LazyTable({ route, columns, defaultPageSize, rowsPerPageOptions }) {\n  const [data, setData] = useState([]);\n\n  const [page, setPage] = useState(1); // 1 indexed\n  const [pageSize, setPageSize] = useState(defaultPageSize ?? 10);\n\n  // Now notice the dependency array contains route, page, pageSize, since we\n  // need to re-fetch the data if any of these values change\n  useEffect(() => {\n    fetch(`${route}?page=${page}&page_size=${pageSize}`)\n      .then(res => res.json())\n      .then(resJson => setData(resJson));\n  }, [route, page, pageSize]);\n\n  const handleChangePage = (e, newPage) => {\n    // Can always go to previous page (TablePagination prevents negative pages)\n    // but only fetch next page if we haven't reached the end (currently have full page of data)\n    if (newPage < page || data.length === pageSize) {\n      // Note that we set newPage + 1 since we store as 1 indexed but the default pagination gives newPage as 0 indexed\n      setPage(newPage + 1);\n    }\n  }\n\n  const handleChangePageSize = (e) => {\n    // when handling events such as changing a selection box or typing into a text box,\n    // the handler is called with parameter e (the event) and the value is e.target.value\n    const newPageSize = e.target.value;\n    // task 18\n    setPageSize(newPageSize);   \n    setPage(1); \n  }\n\n  const defaultRenderCell = (col, row) => {\n    return <div>{row[col.field]}</div>;\n  }\n\n  return (\n    <TableContainer>\n      <Table>\n        <TableHead>\n          <TableRow>\n            {columns.map(col => <TableCell key={col.headerName}>{col.headerName}</TableCell>)}\n          </TableRow>\n        </TableHead>\n        <TableBody>\n          {data.map((row, idx) =>\n            <TableRow key={idx}> \n              {columns.map(col => (\n                // TODO (TASK 19): the next 3 lines of code render only the first column. Wrap this with another map statement to render all columns.\n                // Hint: look at how we structured the map statement to render all the table headings within the <TableHead> element\n                <TableCell key={col.headerName}>\n                  {/* Note the following ternary statement renders the cell using a custom renderCell function if defined, or defaultRenderCell otherwise */}\n                  {col.renderCell ? col.renderCell(row) : defaultRenderCell(col, row)}\n                </TableCell>\n              ))}\n            </TableRow>\n          )}\n        </TableBody>\n        <TablePagination\n          rowsPerPageOptions={rowsPerPageOptions ?? [5, 10, 25]}\n          count={-1}\n          rowsPerPage={pageSize}\n          page={page - 1}\n          onPageChange={handleChangePage}\n          onRowsPerPageChange={handleChangePageSize}\n        />\n      </Table>\n    </TableContainer>\n  )\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}